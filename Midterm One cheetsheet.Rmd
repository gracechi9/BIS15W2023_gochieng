---
title: "Cheat Sheet"
author: "Grace Ochieng"
date: "2023-01-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

 
## Lab One- R studio and R markdown 
To find the mean
```{r}
mean (x)
```
To find the median
```{r}
median(x)
```
To make a vector
```{r}
x<-c(insert your values here by commas)
```

## Lab Two Summary 
Objects classes and Na's
Once an object has been created, you can do things with them.  
```{r}
treatment <- 36
control <- 38

sum(control,treatment)
```

Here we make a new object `my_experiment` that is the sum of the treatment and control. Notice that I use `_` and not spaces.  
```{r}
my_experiment <- sum(treatment, control)
my_experiment
```

## Types of Data ie classes 
```{r}
my_numeric <- 42
my_integer <- 2L #adding an L automatically denotes an integer
my_character <- "universe"
my_logical <- FALSE
my_complex <- 2+4i
```
## Types of Data
There are five frequently used `classes` of data: 1. numeric, 2. integer, 3. character, 4. logical, 5. complex.
You can use the `is()` and `as()` functions to clarify or specify a type of data.
```{r}
is.integer(my_numeric) #is my_numeric an integer?
```

## To find Na
```{r}
is.na(my_missing)
```

```{r}
anyNA(my_missing)
```
## Data Structures
In addition to classes of data, R also organizes data in different ways. These are called data structures and include vectors, lists, matrices, data frames, and factors. For now, we will focus on `vectors`.  

## Vectors
Vectors are a common way of organizing data in R.  We create vectors using the `c` command. The `c` stands for concatenate.  

A numeric vector.
```{r}
my_vector <- c(10, 20, 30)
```

A character vector. Characters always have quotes and may be referred to as "strings".
```{r}
days_of_the_week <- c("Monday", "Tuesday", "Wednesday", "Thrusday", "Friday", "Saturday", "Sunday")
```

A convenient trick for creating a vector is to generate a sequence of numbers.
```{r}
my_vector_sequence <- c(1:100)
my_vector_sequence
```

## Identifying vector elements
We can use `[]` to pull out elements in a vector. We just need to specify their position in the vector; i.e. day 3 is Wednesday.
```{r}
days_of_the_week[3]
```

## Practice
Work through these examples and make adjustments to the values to experiment.

1. Evaluate all numerics in `my_vector_sequence` to determine which has a value of 15.  
```{r}
my_vector_sequence==15
```

2. We can use operators such as <, >, ==, <==, etc. Show all values in `my_vector_sequence` that are less than 10.  How about less than or equal to 10?  
```{r}
my_vector_sequence<10
```

3. If you use `[]` then you only get the values, not the logical evaluation of the entire vector. Experiment with this by adjusting the chunk below.    
```{r}
my_vector_sequence[my_vector_sequence <= 10]
```

```{r}
my_vector_sequence[my_vector_sequence==15]
```

## Data Matrices
Data matrices are a series of stacked vectors, similar to a data table. In the example below, we build a new data matrix using the matrix command.  

Box office earnings for Harry Potter movies (in millions!). Notice that these are separate vectors.  
```{r}
Philosophers_Stone <- c(317.5, 657.1)
Chamber_of_Secrets <- c(261.9, 616.9)
Prisoner_of_Azkaban <- c(249.5, 547.1)
Goblet_of_Fire <- c(290.0, 606.8)
Order_of_the_Phoenix <- c(292.0, 647.8)
Half_Blood_Prince <- c(301.9, 632.4)
Deathly_Hallows_1 <- c(295.9, 664.3)
Deathly_Hallows_2 <- c(381.0, 960.5)
```

Create a new object called `box_office`. Here we are using the `c` command to combine the vectors into one.
```{r}
box_office <- c(Philosophers_Stone, Chamber_of_Secrets, Prisoner_of_Azkaban, Goblet_of_Fire, Order_of_the_Phoenix, Half_Blood_Prince, Deathly_Hallows_1, Deathly_Hallows_2)
box_office
```

Create `harry_potter_matrix` using the `matrix()` command. We need to tell R how to organize the `box_office` vector using the `nrow` and `byrow` commands.
```{r}
harry_potter_matrix <- matrix(box_office, nrow = 8, byrow = T)
harry_potter_matrix
```
## Name the rows and columns
Vectors `region` and `titles`, used for naming.
```{r}
region <- c("US", "non-US")
region
```

```{r}
titles <- c("Philosophers_Stone", "Chamber_of_Secrets", "Prisoner_of_Azkaban", "Goblet_of_Fire", "Order_of_the_Phoenix", "Half_Blood_Prince", "Deathly_Hallows_1", "Deathly_Hallows_2")
titles
```

Name the columns using `colnames()` with the vector region.
```{r}
colnames(harry_potter_matrix) <- region
```

Name the rows using `rownames()` with the vector titles.
```{r}
rownames(harry_potter_matrix) <- titles
```

Print `harry_potter_matrix`.
```{r}
harry_potter_matrix
```

## Using a data matrix
Once you have a data matrix, you can perform lots of different analyses. For example, you can calculate the total earnings of each movie.
```{r}
global <- rowSums(harry_potter_matrix)
global
```

And even add a new column to reflect this calculation. `cbind()` adds columns.
```{r}
all_harry_potter_matrix <- cbind(harry_potter_matrix, global)
all_harry_potter_matrix
```

## Practice
1. What are the total earnings for the US and non-US regions?  
```{r}
harry_potter_matrix <- rowSums(US)
```

2. Add this information to the data matrix. Hint: you are adding a row, not a column.  
```{r}

```

## A few Extras
The same methods of selecting elements in a vector apply to data matrices. We use `[]`. The following selects the value in the first column, second row.
```{r}
harry_potter_matrix[2,1]
```

Adding a colon `:` selects the specified elements in a column.  
```{r}
harry_potter_matrix[1:4]
```

We can also select values in an entire row or column. This can be useful for calculations. Here we calculate the mean of the entire second column. 
```{r}
non_us_earnings <- all_harry_potter_matrix[ ,2]
mean(non_us_earnings)
```

## Homework 2
1. What is a vector in R?  
a vector in R is a way to organise data. For instance in a mean it identifies all values such as the decimal values and calculates a more accurate mean. In vectors we use concatenate as c and then place our values to get a more organised version of our data.
 for example;
```{r}
Gol<- 20.7
Di<-30.8
Locks<-10.2

```
```{r}
total_earnings<-c(Gol,Di,Locks)
mean(total_earnings)
```
 

2. What is a data matrix in R?  
a data matrix in R can be seen as data tables in ythe sence that they are a series of stacked vectors 

3. Below are data collected by three scientists (Jill, Steve, Susan in order) measuring temperatures of eight hot springs. Run this code chunk to create the vectors.  
```{r}
spring_1 <- c(36.25, 35.40, 35.30)
spring_2 <- c(35.15, 35.35, 33.35)
spring_3 <- c(30.70, 29.65, 29.20)
spring_4 <- c(39.70, 40.05, 38.65)
spring_5 <- c(31.85, 31.40, 29.30)
spring_6 <- c(30.20, 30.65, 29.75)
spring_7 <- c(32.90, 32.50, 32.80)
spring_8 <- c(36.80, 36.45, 33.15)
```

4. Build a data matrix that has the springs as rows and the columns as scientists.  
```{r}
temperature<-c(spring_1,spring_2,spring_3,spring_4,spring_5,spring_6,spring_7,spring_8)
temperature
```
```{r}
data_collected_matrix<- matrix(temperature, nrow = 8, byrow = T)
data_collected_matrix
```

5. The names of the springs are 1.Bluebell Spring, 2.Opal Spring, 3.Riverside Spring, 4.Too Hot Spring, 5.Mystery Spring, 6.Emerald Spring, 7.Black Spring, 8.Pearl Spring. Name the rows and columns in the data matrix. Start by making two new vectors with the names, then use `colnames()` and `rownames()` to name the columns and rows.

```{r}
scientists <- c("Jill", "Steve","Susan")
scientists
```

```{r}
spring_names<-c("Bluebell Spring","Opal Spring","Riverside Spring","Too Hot Spring","Mystery Spring","Emerald Spring","Black Spring","Pearl Spring")
spring_names
```

```{r}
colnames(data_collected_matrix) <- scientists
```

```{r}
rownames(data_collected_matrix) <- spring_names
```

The matrix created.

```{r}
data_collected_matrix
```

6. Calculate the mean temperature of all eight springs.
```{r}
total_data <- rowSums(data_collected_matrix)
total_data
```
The calculated mean temperature
```{r}
springs_temperature <-c(total_data)
mean(springs_temperature)
```

7. Add this as a new column in the data matrix.  
```{r}
all_data_collected_matrix <- cbind(data_collected_matrix,total_data)
all_data_collected_matrix
```

8. Show Susan's value for Opal Spring only.
```{r}
data_collected_matrix[2,3]
```

9. Calculate the mean for Jill's column only.  
```{r}
jill <- all_data_collected_matrix[,1]
mean(jill)
```

10. Use the data matrix to perform one calculation or operation of your interest.
I would like to calculate the mean on all the total data the scientists collected
```{r}
total_data<- all_data_collected_matrix[,4]
mean(total_data)
```

## Lab 3 Summary

title: "Data Frames"
## Data Frames
During lab 2, you learned how to work with vectors and data matrices. Today we will organize the vectors into a new type of data structure called a **data frame**. The data frame is the most common way to organize data within R. You can think of a data frame as similar to a spreadsheet. A data frame can store data of many different classes.  

Let's build separate vectors that include length (in), weight (oz), and sex of three [ruby-throated hummingbirds](https://www.audubon.org/field-guide/bird/ruby-throated-hummingbird).  
```{r}
Sex <- c("male", "female", "male")
Length <- c(3.2, 3.7, 3.4)
Weight <- c(2.9, 4.0, 3.1)
```

Here we combine our three vectors to create a data frame with the function `data.frame()`.
```{r}
hbirds <- data.frame(Sex, Length, Weight)
hbirds
```

OK, stop and think- how does this differ from making a data matrix? Are the data treated differently?  
```{r}
hummingbirds <- c(Sex, Length, Weight)
hummingbirds_matrix <- matrix(hummingbirds, nrow=3, byrow = T)
hummingbirds_matrix
```

Notice that not only are the data neat and clean looking, there is also information provided about the class of data. `dbl` means that the value is a type of numeric [double precision floating point](http://uc-r.github.io/integer_double/). 

What are the column names of our data frame? Notice that R defaulted to using the names of our vectors, but we could name them something else when creating the data frame, or rename them later.
```{r}
names(hbirds)
```

What are the dimensions of the `hbirds` data frame? The `dim()` and `str()` commands provide this information.   
```{r}
dim(hbirds)
```

```{r}
str(hbirds)
```

Let's use lowercase names when we create the data frame. We just changed to lowercase here, but we could use any names we wish.  
```{r}
hbirds <- data.frame(sex = Sex, length_in = Length, weight_oz = Weight) #renaming will become more helpful in later labs
names(hbirds)
```

```{r}
hbirds
```

## Accessing Data Frame Columns and Rows 
The same methods of selecting elements in vectors and data matrices apply to data frames. We use `[]`. We have two positions where the first applies to the rows, and the second to the columns.  

The first row.  
```{r}
hbirds[1,]
```

The third column.  
```{r}
hbirds[ ,3]
```

We can also select values in an entire column using the `$` sign. This can be useful for calculations. Here we calculate the mean of all of the birds weights. 
```{r}
w <- hbirds$weight_oz
mean(w)
```

## Adding Rows
We can add a new bird's data with the `rbind()` function, known as row bind. It will bind our new vector to our data frame row-wise.
```{r}
new_bird <- c("female", 3.6, 3.9)
new_bird
```

```{r}
hbirds<- rbind(hbirds, new_bird)
hbirds
```

## Adding Columns
What if we come across more data and we want to add it to our data frame? We can also do that with the `$` operator.
```{r}
hbirds$neighborhood <- c("lakewood", "brentwood", "lakewood", "scenic Heights")
hbirds
```

## Writing Data to File
We should save our hbirds data frame so we can use it again later! There are many ways to save data in R, here we write our data frame to a csv file. We use `row.names = FALSE` to avoid row numbers from printing out. 
```{r}
write.csv(hbirds, "hbirds_data.csv", row.names = FALSE)
```

## Practice
Below are data collected by three scientists (Jill, Steve, Susan in order) measuring temperatures of three hot springs near Mono Lake.
```{r}
temp <- c(36.25, 35.40, 35.30, 35.15, 35.35, 33.35, 30.70, 29.65, 29.20)
name <- c("Jill", "Susan", "Steve", "Jill", "Susan", "Steve", "Jill", "Susan", "Steve")
spring <- c("Buckeye", "Buckeye", "Buckeye", "Benton", "Benton", "Benton", "Travertine", "Travertine", "Travertine")
```

1. Build a data frame called `hsprings` with the above data. Name the temperature column `temp_C`. Print out the data frame.  
```{r}
hsprings <- data.frame(temp, name, spring)
hsprings
```
```{r}
hsprings <- data.frame(temp_C=temp, name=name, spring=spring)
hsprings
```

2. Change the column titled `name` to `scientist`, leave the other column names the same. Print out the data frame names.  
```{r}
hsprings <- data.frame(temp_C=temp, scientist=name, spring=spring)
hsprings
```
to change write the new name equals the old name 
3. Our scientists forgot to record the depth data for each spring. Here it is as a vector, add it as a new column called depth_ft: `c(4.15, 4.13, 4.12, 3.21, 3.23, 3.20, 5.67, 5.65, 5.66)`. Print out the data frame.
```{r}
hsprings$depth_ft <- c(4.15, 4.13, 4.12, 3.21, 3.23, 3.20, 5.67, 5.65, 5.66)
hsprings
```

4. Calculate the mean temperature of all of the temperature measurements.
```{r}
w <- hsprings$temp_C
mean(w)
```

5. Save your hot springs data as a `.csv` file! Do not allow row names. 
```{r}
write.csv(hsprings, "hsprings_data.csv", row.names = FALSE)
```

## Part 3:2 Importing Data Frames

## Summary functions
Once data have been uploaded, you may want to get an idea of its structure, contents, and dimensions. I routinely run one or more of these commands when data are first imported.  

We can summarize our data frame with the`summary()` function.  
```{r}
summary(fish)
```

`glimpse()` is another useful summary function.
```{r}
glimpse(fish)
```

`nrow()` gives the numbers of rows.
```{r}
nrow(fish) #the number of rows or observations
```

`ncol` gives the number of columns.
```{r}
ncol(fish) #the number of columns or variables
```

`dim()` gives the dimensions.
```{r}
dim(fish) #total dimensions
```

`names` gives the column names.
```{r}
names(fish) #column names
```

`head()` prints the first n rows of the data frame.
```{r}
head(fish, n = 10)
```

`tail()` prinst the last n rows of the data frame.
```{r}
tail(fish, n = 10)
```

`table()` is useful when you have a limited number of categorical variables. It produces fast counts of the number of observations in a variable. We will come back to this later... 
```{r}
table(fish$lakeid)
```

We can also click on the `fish` data frame in the Environment tab or type View(fish).
```{r}
#View(fish)
```

## Filter
Filter is a way of pulling out observations that meet specific criteria in a variable. We will work a lot more with this in the next lab.  
```{r}
little_fish <- filter(fish, length<=100)
little_fish
```

## Practice
1. Load the data `mammal_lifehistories_v2.csv` and place it into a new object called `mammals`.
```{r}
mammals <- readr::read_csv("/Users/achichi/Desktop/BIS15W2023_gochieng clone/lab3/data/mammal_lifehistories_v2.csv")
```

2. Provide the dimensions of the data frame.
```{r}
dim(mammals)
```

3. Check the column names in the data frame. 
```{r}
names(mammals)
```

4. Use `str()` to show the structure of the data frame and its individual columns; compare this to `glimpse()`. 
```{r}
str(mammals)
```

5. . Try the `table()` command to produce counts of mammal order, family, and genus.  
Mammal order
```{r}
table(mammals$order)
```

## Lab 3 Homework
How many herbivores are represented in the data?  
```{r}
table(sleep$species)
```

We are interested in two groups; small and large mammals. Let's define small as less than or equal to 1kg body weight and large as greater than or equal to 200kg body weight. Make two new dataframes (large and small) based on these parameters.
```{r}
small_mammals<-filter(msleep, bodywt<=1)
small_mammals
```

```{r}
large_mammals<-filter(msleep,bodywt <=200) 
large_mammals
```

What is the mean weight for both the small and large mammals?
```{r}
w <- small_mammals$bodywt
mean(w)
```
```{r}
w <- large_mammals$bodywt
mean(w)
```

Using a similar approach as above, do large or small animals sleep longer on average?  
```{r}
w <- large_mammals$sleep_total
mean(w)
```

```{r}
w <- small_mammals$sleep_total
mean(w)
```
The smaller mammals sleep longer than average

Which animal is the sleepiest among the entire dataframe?
```{r}
max (msleep$sleep_total)

```

Writing Data to File
```{r}
write.csv(sleep, "mammals_sleep_allison_cicchetti_1976.csv", row.names = FALSE)
```

## Lab 4 Summary Transforming Data Dlpyr's

To keep things tidy, I am going to rename the variables in the mammals data.  
```{r}
mammals <- rename(mammals, genus=Genus, wean_mass="wean mass", max_life="max. life", litter_size="litter size", litters_per_year="litters/year")
```
You start with the new name and equal it to what is being renamed

## `filter()`
Unlike `select()`, `filter()` allows us to extract data that meet specific criteria within a variable. Let's say that we are interested only in the fish that occur in lake "AL". We can use `filter()` to extract these observations.  
```{r}
filter(fish, lakeid == "AL")
```

Similarly, if we are only interested in fish with a length greater than or equal to 350 we can use `filter()` to extract these observations.  
```{r}
filter(fish, length >= 350)
```

+ `filter()` allows all of the expected operators; i.e. >, >=, <, <=, != (not equal), and == (equal).  

Using the `!` operator allows for the exclusion of specific observations.
```{r}
filter(fish, lakeid != "AL")
```

## Using `filter()` with multiple observations  
Filtering multiple values within the same variable requires the `%in%` [operator](https://www.tutorialspoint.com/r/r_operators.htm).    
```{r}
filter(fish, length %in% c(167, 175))
```

Alternatively, you can use `between` if you are looking for a range of specific values.  
```{r}
filter(fish, between(scalelength, 2.5, 2.55))
```

You can also extract observations "near" a certain value but you need to specify a tolerance.  
```{r}
filter(fish, near(radii_length_mm, 2, tol = 0.2))
```

+ `filter()` allows all of the expected operators; i.e. >, >=, <, <=, != (not equal), and == (equal).  

Using the `!` operator allows for the exclusion of specific observations.
```{r}
filter(fish, lakeid != "AL")
```

## Using `filter()` on multiple conditions
You can also use `filter()` to extract data based on multiple conditions. Below we extract only the fish that have lakeid "AL" and length >350.
```{r}
filter(fish, lakeid == "AL" & length > 350)
```

Notice that the `|` operator generates a different result.
```{r}
filter(fish, lakeid == "AL" | length > 350)
```
In this case, we filter out the fish with a length over 400 and a scale length over 11 or a radii length over 8.
```{r}
filter(fish, length > 400, (scalelength > 11 | radii_length_mm > 8))
```

## Select function

We are only interested in lakeid and scalelength.
```{r}
select(fish, "lakeid", "scalelength")
```

To add a range of columns use `start_col:end_col`.
```{r}
fish
```

```{r}
select(fish, fish_id:length)
```

The - operator is useful in select. It allows us to select everything except the specified variables.
```{r}
select(fish, -fish_id, -annnumber, -length, -radii_length_mm)
```

For very large data frames with lots of variables, `select()` utilizes lots of different operators to make things easier. Let's say we are only interested in the variables that deal with length.

```{r}
names(fish)
```

```{r}
select(fish, contains("length"))
```

When columns are sequentially named, `starts_with()` makes selecting columns easier.
```{r}
select(fish, starts_with("radii"))
```

Options to select columns based on a specific criteria include:  
1. ends_with() = Select columns that end with a character string  
2. contains() = Select columns that contain a character string  
3. matches() = Select columns that match a regular expression  
4. one_of() = Select columns names that are from a group of names  

```{r}
names(fish)
```

```{r}
select(fish, ends_with("id"))
```

```{r}
select(fish, contains("fish"))
```

We won't cover [regex](https://en.wikipedia.org/wiki/Regular_expression) in this class, but the following code is helpful when you know that a column contains a letter (in this case "a") followed by a subsequent string (in this case "er").  
```{r}
select(fish, matches("a.+er"))
```

You can also select columns based on the class of data.  
```{r}
glimpse(fish)
```

```{r}
select_if(fish, is.numeric)
```

To select all columns that are *not* a class of data, you need to add a `~`.
```{r}
select_if(fish, ~!is.numeric(.))
```

## Lab 4 Homework
**3. Change the class of the variables `taxon` and `order` to factors and display their levels.**  

Part one- Taxon
Variable of Taxon changed to factor
```{r}
class(homerange$taxon)
```
```{r}
homerange$taxon <-as.factor(homerange$taxon)
class(homerange$taxon)
```

Levels of Taxon
```{r}
levels(homerange$taxon)
```
 
Part Two- order
Variable of 'order' changed to factor
```{r}
homerange$order <-as.factor(homerange$order)
class(homerange$order)
```
 Levels of order
```{r}
levels(homerange$order)
```
 
**4. What taxa are represented in the `homerange` data frame? Make a new data frame `taxa` that is restricted to taxon, common name, class, order, family, genus, species.** 

The taxa represented in the homerange data frame 
```{r}
levels(homerange$taxon)
```

Changing to the 'Taxa' data frame
```{r}
taxa <- select(homerange,taxon: species )
```

**5. The variable `taxon` identifies the large, common name groups of the species represented in `homerange`. Make a table the shows the counts for each of these `taxon`.**  

Table for Common name 
```{r}
table (homerange$common.name)
```

**6. The species in `homerange` are also classified into trophic guilds. How many species are represented in each trophic guild.**  

```{r}
table(homerange$trophic.guild)
```

**7. Make two new data frames, one which is restricted to carnivores and another that is restricted to herbivores.**  

Code chunk only restricted for carnivores data frame
```{r}
carnivore.animals <-filter(homerange, trophic.guild == "carnivore")
```

Data frame for carivores 
```{r}
filter(homerange, trophic.guild == "carnivore")
```

Code chunk only restricted for herbivores data frame
```{r}
herbivore.animals <-filter(homerange, trophic.guild == "herbivore")
```

Data for herbivores
```{r}
filter(homerange, trophic.guild == "herbivore")
```

**8. Do herbivores or carnivores have, on average, a larger `mean.hra.m2`? Remove any NAs from the data.**  
Herbivore
```{r}
mean(herbivore.animals$mean.hra.m2, na.rm=T)
```

Carnivore
```{r}
mean(carnivore.animals$mean.hra.m2, na.rm=T)
```
In comparison herbivores have a larger mean, 'mean.hra.m2'
 
**9. Make a new dataframe `deer` that is limited to the mean mass, log10 mass, family, genus, and species of deer in the database. The family for deer is cervidae. Arrange the data in descending order by log10 mass. Which is the largest deer? What is its common name?**  


```{r}
deer <-select (homerange, "log10.mass", "family", "genus", "mean.mass.g")
deer.cervidae <-filter (deer, family =="cervidae")
deer.cervidae
```

```{r}
arrange (deer.cervidae, log10.mass)
```
The largest deer is the Alcels and its common name is the moose

**10. As measured by the data, which snake species has the smallest homerange? Show all of your work, please. Look this species up online and tell me about it!** **Snake is found in taxon column**   

Now we create a new data set for the viperidae family which are the snakes  
```{r}
snake <-select (homerange, "log10.mass", "family", "genus", "mean.hra.m2")
```

```{r}
snake.x <-filter (deer, family =="viperidae")
snake.x
```

```{r}
arrange (snake.x, log10.mass)
```
  
## Lab 5 Summary 
## title: "Pipes, `arrange()`, `mutate()`, and `if_else()`"
## Pipes `%>%` 
In order to start combining `select()`, `filter()`, and other functions efficiently, we need to learn pipes. Pipes feed the output from one function into the input of another function. This helps us keep our code sequential and clean.  

In this example, we use a pipe to select only `lakeid` and `scalelength` then filter that output only for lakes "AL". Notice that we only need to call the data one time.
```{r}
filter(fish, lakeid == "AL")
```
ony interested in
```{r}
select(fish, lakeid, scalelength)
```
but what if i wanted to connect feed one into the other so the first and second step into just one code chunk and chop up data to what we are intrested in

fish %>%
  select(lakeid, scalelength) %>%
  filter(lakeid == "AL")
  
  
## 5.1 Pipes arrange mutate and if_else

## Review
At this point, you should be comfortable using the `select()` and `filter()` functions of `dplyr`. If you need extra help, please [email me](mailto: jmledford@ucdavis.edu).  

## Load the tidyverse
```{r message=FALSE, warning=FALSE}
library("tidyverse")
```

## Load the data
For this lab, we will use the following two datasets:  

1. Gaeta J., G. Sass, S. Carpenter. 2012. Biocomplexity at North Temperate Lakes LTER: Coordinated Field Studies: Large Mouth Bass Growth 2006. Environmental Data Initiative.   [link](https://portal.edirepository.org/nis/mapbrowse?scope=knb-lter-ntl&identifier=267)  
```{r}
fish <- readr::read_csv("data/Gaeta_etal_CLC_data.csv")
```

2. S. K. Morgan Ernest. 2003. Life history characteristics of placental non-volant mammals. Ecology 84:3402.   [link](http://esapubs.org/archive/ecol/E084/093/)  
```{r}
mammals <- readr::read_csv("data/mammal_lifehistories_v2.csv")
```

```{r}
names(mammals)
```

Let's rename some of the `mammals` variables.  


```{r}
mammals <- rename(mammals, genus="Genus", wean_mass="wean mass", max_life= "max. life", litter_size="litter size", litters_per_year="litters/year")
```


```{r}
names(mammals)
```

```{r}
glimpse(mammals)
```
Tricks to change to factors 
we hav characters that can be changed to factors 
shiftcommandM
```{r}
mammals %>% mutate_if(is.character,as.factor)
```


## Pipes `%>%` 
In order to start combining `select()`, `filter()`, and other functions efficiently, we need to learn pipes. Pipes feed the output from one function into the input of another function. This helps us keep our code sequential and clean.  

In this example, we use a pipe to select only `lakeid` and `scalelength` then filter that output only for lakes "AL". Notice that we only need to call the data one time.
```{r}
filter(fish, lakeid == "AL")
```
ony interested in
```{r}
select(fish, lakeid, scalelength)
```
but what if i wanted to connect feed one into the other so the first and second step into just one code chunk and chop up data to what we are intrested in
```{r}
fish %>%
  select(lakeid, scalelength) %>%
  filter(lakeid == "AL")
```

Here we select family, genus, and species then filter for gestation greater than 15 months.
```{r}
mammals %>% 
  select(family, genus, species, gestation) %>% 
  filter(gestation>=15)
```

## Practice
1. We are interested in the fish from the lakes "AL" and "AR" with a radii length between 2 and 4. Extract this information from the `fish` data. Use pipes!  
```{r}
fish %>% 
  filter(fish, lakeid == "AL"|lakeid == "AR") %>% 
  filter(radii_length_mm>=2 & radii_length_mm<=4)
```

  check the one above 
  
## `arrange()`
The `arrange()` command is a bit like a sort command in excel. Note that the default is ascending order.  
```{r}
fish %>% 
  select(lakeid, scalelength) %>% 
  arrange(scalelength)
```

To sort in decreasing order, wrap the variable name in `desc()`.
```{r}
fish %>% 
  select(lakeid, scalelength) %>% 
  arrange(desc(scalelength))
```

`arrange()` can be very helpful in combination with the other functions.
```{r}
fish %>% 
  select(lakeid, length, fish_id, scalelength) %>% 
  filter(lakeid=="AL") %>% 
  arrange(fish_id)
```

## Practice
1. We are interested in the radii length and scalelength of fish with the id `300`. Extract this information from the `fish` data. Please sort the data by radii length.
```{r}
fish %>%
  filter (fish_id =="300") %>% 
   select(radii_length_mm,fish_id) %>% 
arrange(radii_length_mm)
```

## `mutate()`  
Mutate allows us to create a new column from existing columns in a data frame. We are doing a small introduction here and will add some additional functions later. Let's convert the length variable from cm to millimeters and create a new variable called length_mm.  
```{r}
fish %>% 
  mutate(length_mm = length*10) %>% 
  select(fish_id, length, length_mm)
```

## `mutate_all()`
This last function is super helpful when cleaning data. With "wild" data, there are often mixed entries (upper and lowercase), blank spaces, odd characters, etc. These all need to be dealt with before analysis.  

Here is an example that changes all entries to lowercase (if present).  
```{r}
mammals
```
to change all the column nams to lowercase
```{r}
mammals %>%
  mutate_all(tolower)
```

Using the across function we can specify individual columns. that we might want to get to lowercase
```{r}
mammals %>% 
  mutate(across(c("order", "family"), tolower))
```

## `if_else()`
We will briefly introduce `if_else()` here because it allows us to use `mutate()` but not have the entire column affected in the same way. In a sense, this can function like find and replace in a spreadsheet program. With `ifelse()`, you first specify a logical statement, afterwards what needs to happen if the statement returns `TRUE`, and lastly what needs to happen if it's  `FALSE`.  

Have a look at the data from mammals below. Notice that the values for newborn include `-999.00`. This is sometimes used as a placeholder for NA (but, is a really bad idea). We can use `if_else()` to replace `-999.00` with `NA`.  
```{r}
mammals %>% 
  select(genus, species, newborn) %>% 
  arrange(newborn)
```
make a new column and if its in the new born there is a -999 put na if not -99 keep the oldvalue
```{r}
mammals %>% 
  select(genus, species, newborn) %>%
  mutate(newborn_new = ifelse(newborn == -999.00, NA, newborn))%>% 
  arrange(newborn)
```

## Practice
1. Use `mutate()` to make a new column that is the half length of each fish: length_half = length/2. Select only fish_id, length, and length_half.
```{r}
fish %>% 
  mutate(length_half=length/2) %>% 
  arrange(length_half,fish_id,length)
```

## Load the tidyverse
```{r}
library("tidyverse")
```

## Load the superhero data
These are data taken from comic books and assembled by fans. The include a good mix of categorical and continuous data.  Data taken from: https://www.kaggle.com/claudiodavi/superhero-set  

Check out the way I am loading these data. If I know there are NAs, I can take care of them at the beginning. But, we should do this very cautiously. At times it is better to keep the original columns and data intact.  
```{r}
superhero_info <- readr::read_csv("data/heroes_information.csv", na = c("", "-99", "-"))
superhero_powers <- readr::read_csv("data/super_hero_powers.csv", na = c("", "-99", "-"))
```
removed a lot of the problems
## Data tidy
1. Some of the names used in the `superhero_info` data are problematic so you should rename them here.  
```{r}
names(superhero_info)
```

```{r}
superhero_info <- rename(superhero_info, name="name", gender="Gender", eye_color= "Eye color", race="Race", hair_color="Hair color", height="Height", publisher="Publisher", skin_color="Skin color", alignment="Alignment", weight="Weight")
```

Yikes! `superhero_powers` has a lot of variables that are poorly named. We need some R superpowers...
```{r}
head(superhero_powers)
```

## `janitor`
The [janitor](https://garthtarr.github.io/meatR/janitor.html) package is your friend. Make sure to install it and then load the library.  
```{r message=FALSE, warning=FALSE} 
library ("janitor")
```

The `clean_names` function takes care of everything in one line! Now that's a superpower!
```{r}
superhero_powers <- 
  janitor::clean_names(superhero_powers)
superhero_powers
```

## 5.2 Superhero

## `tabyl`
The `janitor` package has many awesome functions that we will explore. Here is its version of `table` which not only produces counts but also percentages. Very handy! Let's use it to explore the proportion of good guys and bad guys in the `superhero_info` data.  

```{r}
#tabyl(superhero_info, alignment)
superhero_info
```

2. Notice that we have some neutral superheros! Who are they?
we find the names of the 
```{r}
superhero_info %>% 
  filter(race=="Human")
```

## `superhero_info`
3. Let's say we are only interested in the variables name, alignment, and "race". How would you isolate these variables from `superhero_info`?
```{r}
superhero_info %>% 
  select(alignment, race)
```

## Not Human
4. List all of the superheros that are not human.
```{r}
superhero_info %>%
  filter(race!= "Human")
```

## Good and Evil(check this question)
5. Let's make two different data frames, one focused on the "good guys" and another focused on the "bad guys".
Good Guys dataframe

```{r}
alignment_category<- select (superhero_info,"name", "hair_color", "race", "alignment","height", "weight")
good_guys <- filter(alignment_category, alignment =="good")
good_guys
```
Bad Guys Data frame
```{r}
alignment_category<- select (superhero_info, "name", "hair_color", "race", "alignment","height")
bad_guys <-filter (alignment_category, alignment =="bad")
bad_guys
```


6. For the good guys, use the `tabyl` function to summarize their "race".
```{r}
#tabyl(good_guys, race)
good_guys

```

7. Among the good guys, Who are the Asgardians?
```{r}
filter(good_guys, race =="Asgardian")
```

8. Among the bad guys, who are the male humans over 200 inches in height?
```{r}
filter(bad_guys, height>=200 )
```

9. OK, so are there more good guys or bad guys that are bald (personal interest)?
```{r}
 bad_guys %>%
  select(name, hair_color,race) %>%
  filter(hair_color == "No Hair") 
```
```{r}
good_guys %>%
  select(name, hair_color,race) %>%
  filter(hair_color == "No Hair")
```

10. Let's explore who the really "big" superheros are. In the `superhero_info` data, which have a height over 200 or weight greater than or equal to 450?
```{r}
superhero_info %>%
  select(name, height,weight) %>%
  filter(height >300 | weight>=450 )
```

11. Just to be clear on the `|` operator,  have a look at the superheros over 300 in height...
```{r}
superhero_info %>%
  select(name, height,weight) %>%
  filter(height>300)
```

12. ...and the superheros over 450 in weight. Bonus question! Why do we not have 16 rows in question #10?
```{r}
superhero_info %>%
  select(name, height,weight) %>%
  filter(weight>=450)
```
  
We don't have 16 rows in total in comparison to the first because in the first code we ran it asks for or in this function as long as one of the variables meets the criteria we are searching for it will show up. However, according to the second and third code it asks specifically for weight being a specific numeric and the other similarly only asks for height.
 
## Height to Weight Ratio
13. It's easy to be strong when you are heavy and tall, but who is heavy and short? Which superheros have the highest height to weight ratio?
```{r}
superhero_info %>%
  select(name, height,weight) %>%
  filter(height<100 & weight>450 )
```

## `superhero_powers`
Have a quick look at the `superhero_powers` data frame.  
```{r}
glimpse(superhero_powers)
```

14. How many superheros have a combination of accelerated healing, durability, and super strength?
```{r}
superhero_powers %>% 
  select(hero_names, accelerated_healing, durability,super_strength) %>% 
  filter(accelerated_healing=="TRUE" & durability=="TRUE" & super_strength=="TRUE")
```
97 Heros have a combination of the three traits 

## Your Favorite
15. Pick your favorite superhero and let's see their powers!

```{r}
superhero_powers %>%
  filter(hero_names=="Silver Surfer") %>% 
  select_if(all_vars(.=="TRUE"))
```
  
## 6.1 Summarize tanyl group by 

## Load the tidyverse and janitor
```{r message=FALSE, warning=FALSE}
library("tidyverse")
library("janitor")
```

## Install `skimr`
```{r}
#install.packages("skimr")
library("skimr")
```

## Load the data
For this lab, we will use the built-in data on mammal sleep patterns. From: _V. M. Savage and G. B. West. A quantitative, theoretical framework for understanding mammalian sleep. Proceedings of the National Academy of Sciences, 104 (3):1051-1056, 2007_.
```{r}
?msleep
names(msleep)
```

We will also use the awesome [palmerpenguins](https://allisonhorst.github.io/palmerpenguins/articles/intro.html) data in the second part of lab.
```{r}
library("palmerpenguins")
palmerpenguins::penguins_raw
```

## dplyr Practice
Let's do a bit more practice to make sure that we understand `select()`, `filter()`, and `mutate()`. Start by building a new data frame `msleep24` from the `msleep` data that: contains the `name` and `vore` variables along with a new column called `sleep_total_24` which is the amount of time a species sleeps expressed as a proportion of a 24-hour day. Remove any rows with NA's and restrict the `sleep_total_24` values to less than 0.3. Arrange the output in descending order.  
```{r}
msleep24<-msleep %>% 
  mutate(sleep_total_24=sleep_total/24) %>%
  select(name,vore,sleep_total_24) %>% 
  filter(!is.na(vore)) %>% 
  filter(sleep_total_24<=0.3) %>% 
  arrange(desc(sleep_total_24))
```
 
```{r}
msleep24
```
 
 
Did `dplyr` do what we expected? How do we check our output? Remember, just because your code runs it doesn't mean that it did what you intended.
```{r}
summary(msleep24)
```

Try out the new function `skim()` as part of the `skimr` package.
```{r}
skim(msleep24)
```

Histograms are also a quick way to check the output.
```{r}
hist(msleep24$sleep_total_24)
```

Don't forget we can also use `tabyl()` across one or many variables.
```{r}
msleep24 %>% 
  tabyl(vore) %>% 
  adorn_pct_formatting(digits=1)
```

## Practice
1. Which taxonomic orders have species that belong to more than one class of `vore`?
```{r}
names(msleep)
```

```{r}
msleep %>% 
  tabyl(vore,order)
```

## `summarize()`
`summarize()` will produce summary statistics for a given variable in a data frame. For example, if you are asked to calculate the mean of `sleep_total` for large and small mammals you could do this using a combination of commands, but it isn't very efficient or clean. We can do better!  
```{r}
head(msleep)
```

For example, if we define "large" as having a `bodywt` greater than 200 then we get the following:
```{r}
large <- 
  msleep %>% 
  select(name, genus, bodywt, sleep_total) %>% 
  filter(bodywt > 200) %>% 
  arrange(desc(bodywt))
large
```

```{r}
mean(large$sleep_total)
```

We can accomplish the same task using the `summarize()` function to make things cleaner.
```{r}
msleep %>% 
  filter(bodywt > 200) %>% #large mammals
  summarize(mean_sleep_lg = mean(sleep_total))
```

You can also combine functions to make useful summaries for multiple variables.
```{r}
msleep %>% 
    filter(bodywt > 200) %>% 
    summarize(mean_sleep_lg = mean(sleep_total), 
              min_sleep_lg = min(sleep_total),
              max_sleep_lg = max(sleep_total),
              total = n())
```

## Practice
1. What is the mean, min, and max `bodywt` for the taxonomic order Primates? Provide the total number of observations.
```{r}
names(msleep)
```

```{r}
msleep %>% 
  filter(order=="Primates") %>% 
  summarize(mean_bodywt=mean(bodywt),
            min_bodywtw=min(bodywt),
            max_bodywt=max(bodywt),
            total=n())
  
```

`n_distinct()` is a very handy way of cleanly presenting the number of distinct observations. Here we show the number of distinct genera over 100 in body weight.
```{r}
msleep %>% 
  filter(bodywt > 100) %>% 
  summarise(n_genera=n_distinct(genus))
```

There are many other useful summary statistics, depending on your needs: sd(), min(), max(), median(), sum(), n() (returns the length of a column), first() (returns first value in a column), last() (returns last value in a column) and n_distinct() (number of distinct values in a column).

## Practice
1. How many genera are represented in the msleep data frame?
```{r}
msleep %>% 
  summarise(n_genera=n_distinct(genus))
```

2. What are the min, max, and mean `sleep_total` for all of the mammals? Be sure to include the total n.
```{r}
msleep %>%  
    filter(bodywt > 200) %>% 
    summarize(mean_sleep_lg = mean(sleep_total), 
              min_sleep_lg = min(sleep_total),
              max_sleep_lg = max(sleep_total),
              total = n())
```



## `group_by()`
The `summarize()` function is most useful when used in conjunction with `group_by()`. Although producing a summary of body weight for all of the mammals in the data set is helpful, what if we were interested in body weight by feeding ecology?
```{r}
msleep %>%
  group_by(vore) %>% #we are grouping by feeding ecology, a categorical variable
  summarize(min_bodywt = min(bodywt),
            max_bodywt = max(bodywt),
            mean_bodywt = mean(bodywt),
            total=n())
```
  
## 6.2 Summarize practice count and across

## Load the libraries
```{r message=FALSE, warning=FALSE}
library("tidyverse")
library("janitor")
library("skimr")
library("palmerpenguins")
```

## Review
The summarize() and group_by() functions are powerful tools that we can use to produce clean summaries of data. Especially when used together, we can quickly group variables of interest and save time. Let's do some practice with the [palmerpenguins(https://allisonhorst.github.io/palmerpenguins/articles/intro.html) data to refresh our memory.
```{r}
glimpse(penguins)
```

As biologists, a good question that we may ask is how do the measured variables differ by island (on average)?
```{r}
penguins %>% 
  group_by(island) %>% 
  summarise(mean_body_mass=mean(body_mass_g))
```

Why do we have NA here? Do all of these penguins lack data?
```{r}
penguins %>% 
  group_by(island) %>% 
  summarise(mean_body_mass=mean(body_mass_g),na.r=T)
```

Well, that won't work so let's remove the NAs and recalculate.

penguins %>% 
  filter(!is.nabody_masss_g0)
  group_by(island) %>% 
  summarise(mean_body_mass=mean(body_mass_g),na.r=T)
What if we are interested in the number of observations (penguins) by species and island?
```{r}
names(penguins)
```

```{r}

```

## Counts
Although these summary functions are super helpful, oftentimes we are mostly interested in counts. The [janitor package](https://garthtarr.github.io/meatR/janitor.html) does a lot with counts, but there are also functions that are part of dplyr that are useful.  

`count()` is an easy way of determining how many observations you have within a column. It acts like a combination of `group_by()` and `n()`.
```{r}
penguins %>% 
  count(island, sort = T) #sort=T sorts the column in descending order
```

Compare this with `summarize()` and `group_by()`.
```{r}
penguins %>% 
  group_by(island) %>% 
  summarize(n=n())
```

You can also use `count()` across multiple variables.
```{r}
penguins %>% 
  count(island, species, sort = T) # sort=T will arrange in descending order
```

For counts, I often prefer `tabyl()`. Lots of options are supported in [tabyl](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html)
```{r}
penguins %>% 
  tabyl(island, species)
```

```{r}
penguins %>% 
  tabyl(species, island) %>% 
  adorn_percentages() %>%
  adorn_pct_formatting(digits = 2)
```

## Practice
1. Produce a summary of the mean for bill_length_mm, bill_depth_mm, flipper_length_mm, and body_mass_g within Adelie penguins only. Be sure to provide the number of samples.
```{r}

```

2. How does the mean of `bill_length_mm` compare between penguin species?
```{r}

```

3. For some penguins, their sex is listed as NA. Where do these penguins occur?
```{r}

```

## `across()`
What about using `filter()` and `select()` across multiple variables? There is a function in dplyr called `across()` which is designed to work across multiple variables. Have a look at Rebecca Barter's awesome blog [here](http://www.rebeccabarter.com/blog/2020-07-09-across/) as I am following her below.  

What if we wanted to apply summarize in order to produce distinct counts over multiple variables; i.e. species, island, and sex? Although this isn't a lot of coding you can image that with a lot of variables it would be cumbersome.
```{r}
penguins %>%
  summarize(distinct_species = n_distinct(species),
            distinct_island = n_distinct(island),
            distinct_sex = n_distinct(sex))
```

```{r}
names(penguins)
```

By using `across()` we can reduce the clutter and make things cleaner. 
```{r}
penguins %>%
  summarize(across(c(species, island, sex), n_distinct))
```

This is very helpful for continuous variables.
```{r}
penguins %>%
  summarize(across(contains("mm"), mean, na.rm=T))
```

`group_by` also works.
```{r}
penguins %>%
  group_by(sex) %>% 
  summarize(across(contains("mm"), mean, na.rm=T))
```

Here we summarize across all variables.
```{r}
penguins %>%
  summarise_all(mean, na.rm=T)
```

Operators can also work, here I am summarizing across all variables except `species`, `island`, `sex`, and `year`.
```{r}
penguins %>%
  summarise(across(!c(species, island, sex, year), 
                   mean, na.rm=T))
```

All variables that include "bill"...all of the other dplyr operators also work.
```{r}
penguins %>%
  summarise(across(starts_with("bill"), mean, na.rm=T))
```












